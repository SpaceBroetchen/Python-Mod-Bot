import hashlib
import shutil
import zipfile
import json
import re
from packaging.version import Version

import configImport
from BlueprintGenerator.DataFileLoader import DataFile
from configImport import *
import os

default_mods = {"base", "core", "space-age", "elevated-rails", "quality"}

MOD_CACHE = os.path.join(CACHE, "mods")
DEFINES_CACHE = os.path.join(CACHE, "api")



def hashModDictionary(mods):
    l = []
    for i in mods.keys():
        l.append(f"{i}=={mods[i]}")
    return hashlib.md5(";".join(l).encode(encoding='UTF-8')).hexdigest()


def locateSource(mod, version):
    if mod in default_mods:
        path = os.path.join(FACTORIO_DATA, mod)
    else:
        path = os.path.join(FACTORIO_MOD_FOLDER, f"{mod}_{version}")
        if not os.path.exists(path):
            path += ".zip"

    if not os.path.exists(path):
        print(f"Missing {mod}=={version}")
        return None
    return path


def copyMod(mod, version):
    source = locateSource(mod, version)
    if source is None:
        return False
    if os.path.isdir(source):
        shutil.copytree(source, os.path.join(MOD_CACHE, mod))
        return True
    shutil.copy(source, MOD_CACHE)
    with zipfile.ZipFile(os.path.join(MOD_CACHE, os.path.basename(source))) as z:
        z.extractall(MOD_CACHE)
    os.remove(os.path.join(MOD_CACHE, os.path.basename(source)))
    if os.path.exists(os.path.join(MOD_CACHE, mod)):
        return True
    os.renames(os.path.join(MOD_CACHE, os.path.splitext(os.path.basename(source))[0]), os.path.join(MOD_CACHE, mod))
    return True


def createModCache():
    clearModCache()
    if not os.path.exists(MOD_CACHE):
        os.mkdir(MOD_CACHE)
    fails = 0
    success = 0
    active = {}
    for i in MODS.keys():
        if copyMod(i, MODS[i]):
            success += 1
            active[i] = MODS[i]
        else:
            fails += 1
    print(f"loaded {success} mods successfully, failed {fails}")
    print(f"current mod hash: {hashModDictionary(active)}")


def clearModCache():
    if os.path.exists(MOD_CACHE):
        shutil.rmtree(MOD_CACHE)


def createDefinesCache():
    clearDefinesCache()
    if not os.path.exists(DEFINES_CACHE):
        os.mkdir(DEFINES_CACHE)

    with open(os.path.join(DEFINES_CACHE, "defines.lua"), "w") as write_file:
        with open(FACTORIO_PROTOTYPE_API_JSON) as f:
            api = json.load(f)
            write_file.write(
                f"-- This file has been autogenerated, it contains all the defines for Factorio version {api['application_version']}\n\n\n")
            write_file.write("defines = {\n")
            for i in api["defines"]:
                write_file.write("\t[\"" + i['name'] + "\"] = {\n")
                try:
                    for idx, j in enumerate(i["values"]):
                        write_file.write(f"\t\t[\"{j['name']}\"] = {idx},\n")
                except KeyError:
                    try:
                        for idx, j in enumerate(i["subkeys"]):
                            write_file.write(f"\t\t[\"{j['name']}\"] = {{\n")

                            for idx2, j2 in enumerate(j["values"]):
                                write_file.write(f"\t\t\t[\"{j2['name']}\"] = {idx2},\n")
                            write_file.write("\t\t},\n")
                    except KeyError:
                        try:
                            for idx2, j2 in enumerate(j["subkeys"]):
                                write_file.write(f"\t\t\t[\"{j2['name']}\"] = {{\n")
                                # TODO: need to implement triple nested logic to adapt to __base__\data-updates.lua:4

                                for idx3, j3 in enumerate(j2["values"]):
                                    write_file.write(f"\t\t\t\t[\"{j3['name']}\"] = {idx3},\n")
                                write_file.write("\t\t\t},\n")
                                write_file.write("\t\t},\n")
                        except KeyError:
                            print("found tripple loop!")

                write_file.write("\t},\n")
            write_file.write("\t[\"deepcopy\"] = table.deepcopy\n")
            write_file.write("}\n")


def clearDefinesCache():
    if os.path.exists(DEFINES_CACHE):
        shutil.rmtree(DEFINES_CACHE)


def fetchActiveMods():
    mods = {}
    with open(os.path.join(FACTORIO_MOD_FOLDER, "mod-list.json")) as mod_list:
        available = json.load(mod_list)
        for i in available["mods"]:
            if i["enabled"]:
                if "version" in i.keys():
                    mods[i["name"]] = i["version"]
                else:
                    mods[i["name"]] = None

    mod_list = os.listdir(FACTORIO_MOD_FOLDER)
    if "mod-list.json" in mod_list:
        mod_list.remove("mod-list.json")
    if "mod-settings.dat" in mod_list:
        mod_list.remove("mod-settings.dat")

    for i in mods.keys():
        if mods[i] is not None:
            # skipping mods which already have a version and not versioned mods
            continue
        if i in default_mods:
            mods[i] = ""
            continue
        mod_regex = re.compile(r"(?<=^" + i + r"_)\d+\.\d+\.\d+((?=\.zip$)|$)")
        available_versions = []
        for j in mod_list:
            if mod_regex.search(j) is None:
                continue
            available_versions.append(mod_regex.search(j).group(0))
            mod_list.remove(j)
        versions = []
        for j in available_versions:
            versions.append(Version(j))
        if len(versions) == 0:
            print(f"No matching version found for {i}!")

        mods[i] = str(max(versions))
    global MODS
    MODS = mods

def fetchActiveModSettings():

    configImport.MOD_SETTINGS = DataFile(FACTORIO_SETTINGS_FILE)


if FETCH_MODS_AUTOMATICALLY:
    fetchActiveMods()
if FETCH_MOD_SETTINGS_AUTOMATICALLY:
    fetchActiveModSettings()

#createDefinesCache()